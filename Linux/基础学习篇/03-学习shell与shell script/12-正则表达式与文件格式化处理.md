### 12.1 前言：什么是正则表达式

***

1.什么是正则表达式

+ 正则表达式就是处理字符串的方法，它是以行为单位来进行字符串的处理行为，正则表达式通过一些特殊符号的辅助，可以让用户轻易达到查找、删除、替换某特定字符串的处理程序。



2.正则表达式对于系统管理员的用途

+ 通过正则表达式的功能，将这些登录的信息进行处理，仅取出“有问题”的信息来进行分析。



3.正则表达式的广泛用途

+ 过滤不良邮件



4.正则表达式与Shell在Linux当中的角色定位

+ 任督二脉



5.扩展的正则表达式

+ 正则表达式的字符串表示方式依照不同的严谨度而分为基础正则表达式与扩展正则表达式。

+ 字符串处理

+ 组的字符串处理：例如进行查找VBird或netman或lman的查找，注意是或（or）

+ 通过特殊的"("与"|"等字符的协助

  

### 12.2 基础正则表达式

***

1.语系对正则表达式的影响

+ 需要特别留意当时环境的语系为何，否则可能会发现与别人不相同的选取结果。
+ 特殊符号
  + `[:alnum:]`		代表英文大小写字符及数字，即0-9，A-Z，a-z
  + `[:alpha:]`        代表任何英文大小写字符，即A-Z，a-z
  + `[:blank:]`        代表空格键与[Tab]按键
  + `[:cntrl:]`        代表键盘上面的控制按键，即包括CR，LF，Tab，Del等
  + `[:digit:]`        代表数字而已，即0-9
  + `[:graph:]`        除了空格符（空格键与[Tab]按键外的其他所有按键）
  + `[:lower:]`        代表小写字符，即a-z
  + `[:print:]`        代表任何可以被打印出来的字符
  + `[:punct:]`        代表标点符号（punctuation symbol），即" ' ? ! ; : # $
  + `[:upper:]`         代表大写字符，即A-Z
  + `[:sapce:]`         任何会产生空白的字符，包括空格键[Tab]CR等
  + `[:xdigit:]`       代表十六进制的数字类型，因此包括0-9，A-F，a-f的数字与字符ß



2.grep的一些高级参数

+ grep [-A] [-B] [--color=auto] '搜索字符串' filename
  + -A：后面可加数字，为after的意思，除了列出该行外，后续的n行也列出来
  + -B：后面可加数字，为befer的意思，除了列出该行外，前面的n行也列出来
  + --color=auto：可将正确的那个选取数据列出颜色
  + -v：反向选择
  + -i：忽略大小写
+ 用dmesg列出内核信息，再以grep找出内含eth的那行，加行号，关键字显色，同时列出前三行，后三行
  + `dmesg | grep -n -A3 -B3 --color=auto 'eth'`
+ grep在数据中查找一个字符串时，是以整行为单位来进行数据的选取的。
+ 在~/.bashrc内加上这行：`alias grep='grep --color=auto'`，再以source ~/.bashrc来立即生效



3.基础正则表达式练习

+ 利用中括号[]来查找集合字符
  + `grep -n 't[ae]st' filename`
+ 反向选择：oo前面不能有g
  + `grep -n '[^g]oo' filename`
+ 不想要小写字符
  + `grep -n '[^a-z]oo' filename`
  + `grep -n '[^[:lower:]]oo' filename`
+ 取得数字
  + `grep -n '[0-9]' filename`
  + `grep -n '[[:digit:]]' filename`
+ 取得字符串及英文：[a-zA-Z0-9]或[:alnum:]



+ 行首与行尾字符^$
+ the只在行首列出
  + `grep -n '^the' filename`
+ 开头是小写字符
  + `grep -n '^[a-z]' filename`
  + `grep -n '^[[:lower:]]' filename`
+ 开头不是英文字母
  + `grep -n '^[^[a-zA-Z]]' filename`
  + **^在[]内代表反向选择**
  + **^在[]外代表定位在行首**
+ 行尾结束为小数点（.）的那一行
  + `grep -n '¥.$' filename`
+ 找出空白行
  + `grep -n '^$' filename`
+ 不要空白行和批注
  + `grep -v '^$' filename | grep -v '^#'`



+ 任意一个字符.与重复字符*
  + 通配符*可以用来代表任意（0或多个）字符，但是正则表达式并不是通配符
  + .(小数点)：代表一定有一个任意字符的意思
  + *(星号)：代表重复前一个0到无穷多次的意思，为组合形态
+ g与d之间一定要存在两个字符
  + `grep -n 'g..d' filename`
+ 列出oo,ooo,oooo
  + `grep -n 'ooo*' filename`
+ 找出g开头g结尾的字符串
  + `grep -n 'g.*g' filename`
  + __.*就代表零个或多个任意字符的意思__
+ 任意数字
  + `grep -n '[0-9][0-9]*' filename`
  + `grep -n '[0-9]' filename`



+ 限定连续RE字符范围{}，{}在shell中有特殊意义，需要转义
+ 找到两个o的字符串
  + `grep -n 'o¥{2¥}' filename`
+ 找出g后面接2到5个o，然后再接一个g的字符串
  + `grep -n 'go¥{2,5¥}g' filename`
+ 2个以上的o
  + `grep -n 'go¥{2,¥}g' filename`



4.基础正则表达式字符（characters）

+ ^word
  + 待查找的字符串（word）在行首
  + 查找行首为#开始的那一行，并列出行号
  + `grep -n '^#' filename`
+ word$
  + 待查找的字符串（word）在行尾
  + 查找的字符串可以是（eve）（eae）（eee）（ee），但不能仅有（ee）！即e与e之间“一定”仅有一个字符，而空格符也是字符
  + `grep -n 'e.e' filename`
+ ¥
  + 转义字符，将特殊符号的特殊意义去除
  + 查找含有单引号'的那一行
  + `grep -n ¥' filename`
+ *
  + 重复零个到无穷多个的前一个字符
  + 找出含有（es）（ess）（esss）的字符串
  + `grep -n 'ess*' filename`
+ [list]
  + 从字符集合的RE字符里面找出想要选取的字符
  + 查找含有（gl）或（gd）的那一行
  + `grep -n 'g[ld] filename'`
+ [n1-n2]
  + 从字符集合的RE字符里面找出想要选取的字符范围
  + 查找含有任意数字的那一行。
  + `grep -n '[0-9]' filename`
+ [^list]
  + 从字符集合的RE字符里面找出不要的字符串或范围
  + 查找的字符串可以是（oog）（ood）但不能是（oot），那个^在[]内时代表的意义是“反向选择”的意思
  + `grep -n 'oo[t]' filename`
+ ¥[n,m¥]
  + 连续n到m个的前一个RE字符，若为¥[n¥]则是连续n个的前一个RE字符，若为¥[n,¥]则是连续n个以上的前一个RE字符
  + `grep -n 'go¥[2,3¥]g' filename`
+ **再次强调：正则表达式的特殊字符与一般在命令行的“通配符”并不相同**
  + 在通配符当中的*代表的是零到无限多个字符的意思，
  + 但在正则表达式当中，*则是重复0到无穷多个的前一个RE字符的意思，使用的意义并不相同。
  + ls | grep -n '^a.*'



5.sed工具

+ sed [-nefr] 动作
  + -n：使用安静（silent）模式。在一般sed的用法中，所有来自STDIN的数据一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行（或者操作）才会被列出来。
  + -e：直接在命令行模式上进行sed的动作编辑。
  + -f：直接将sed的动作写在一个文件内，-f filename 则可以执行filename内的sed动作
  + -r：sed的动作支持的是扩展型正则表达式的语法（默认是基础正则表达式语法）
  + -i：直接修改读取的文件内容，而不是有屏幕输出。
  + 动作说明：[n1,[n2]] function
    + N1,n2：不见得会存在，一般代表选择进行动作的行数
  + function有下面这些参数：
    + a：新增，a的后面可以接字符串，而这些字符串会在新的一行出现（目前的下一行）；
    + c：替换，c的后面可以接字符串，这些字符串可以替换n1，n2之间的行；
    + d：删除，因为是删除，所以d后面通常不接任何参数；
    + i：插入，i的后面可以接字符串，而这些字符串会在新的一行出现（目前的上一行）；
    + p：打印，也就是将某个选择的数据打印出来。通常p会与参数sed -n一起运行。
    + s：替换，可以直接进行替换的工作。通常这个s的动作可以搭配正则表达式。例：`1,20s/old/new/g`



+ 以行为单位的新增/删除功能
+ 将/etc/passwd 的内容列出并且打印行号，同时，请将第2-5行删除！
  + `nl /etc/passwd | sed '2,5d'`
+ 在第二行后（即是加在第三行）加上“drink tea？”字样！
  + `nl /etc/passwd | sed '2a drink tea'`
+ 新增好几行
  + `nl /etc/passwd | sed '2a Drink tea or ......¥drink beer?'`
  + 加入反斜杠"¥"来进行新行的增加



+ 以行为单位的替换与显示功能
+ 将第2～5行的内容替换成为“No 2-5 Number”
  + `nl /etc/passwd | sed '2,5c No 2-5 number'`
+ 仅列出/etc/passwd文件内的第5-7行
  + `nl /etc/passwd | sed -n '5,7p'`
  + -n是安静模式，如果没有，5-7行会重复输出



+ 部分数据的查找并替换的功能
  + sed 's/要被替换的字符串/新的字符串/g'
+ 删除批注之后的数据和空白行
  + `cat /etc/man.config | grep 'MAN' | sed 's/#.*$//g' | sed '/^$/d'`



+ 直接修改文件内容（危险操作）
+ 利用sed将文件内每一行结尾为"."的换成"!"
  + `sed -i 's/¥.$/¥!/g' filename`
+ 直接在文件最后一行加入“# This is a test”
  + `sed -i '$a # This ia a test' filename`
  + $：代表最后一行
  + a：新增



### 12.3 扩展正则表达式

***

+ 例：去除空白行与行首为#的行列
  + 基础型正则：`grep -v '^$' filename | grep -v '^#'`
  + 扩展型正则：`egrep -v '^$|^#' filename`



+ +
  + 重复一个或一个以上的前一个RE字符
  + 查找（god）（good）（goood）等的字符串。o+代表一个以上的o
  + `egrep -n 'go+d' filename`
+ ?
  + 零个或一个的前一个RE字符
  + 查找（gd）（god）这两个字符串。o？代表空的或一个o
  + `egrep -n 'go?d' filename`
+ |
  + 用或（or）的方式找出数个字符串
  + 查找gd或good这两个字符串
  + `egrep -n 'gd|good' filename`
+ ()
  + 找出组字符串
  + 查找（glad）或（good）这两个字符串
  + `egrep -n 'g(la|oo)d' filename`
+ ()+
  + 多个重复组的判别
  + 找开头是A，结尾是C，中间有一个以上的“xyz”字符串的意思
  + `echo 'AxyzxyzxyzxyzC' | egrep 'A(xyz)+C'`
+ !在正则表达式当中并不是特殊字符
  + 查找文件中含有!与<的字行
  + `grep -n '[!<]' filename`



### 12.4 文件的格式化与相关处理

***

1.格式化打印：printf

+ Printf '打印格式' 实际内容
+ 参数：格式
  + ¥a：警告声音输出
  + ¥b：退格键
  + ¥f：清除屏幕
  + ¥n：输出新的一行
  + ¥r：亦即Enter按键
  + ¥t：水平的[tab]按键
  + ¥v：垂直的[tab]按键
  + ¥xNN：NN为两位数的数字，可以转换数字成为字符
+ c程序语言内，常见的变量格式
  + %ns：那个n是数字，s代表string，即多少个字符；
  + %ni：那个n是数字，i代表integer，即多少整数字数；
  + %N.nf：那个n与N都是数字，f代表floating（浮点）；全部长度为N个，.占一位，n为几个小数位；



2.aws：好用的数据处理工具

+ awk主要是处理每一行的字段内的数据，而默认的字段的分隔符为空格键或[tab]键
+ awk '条件类型1{动作1} 条件类型2{动作2} ...' filename



+ NF
  + 每一行（$0）拥有的字段总数
+ NR
  + 目前awk所处理的是“第几行”数据
+ FS
  + 目前的分隔字符，默认是空格键

+ awk后续的所有动作都是以单引号括住的，想要以print打印时，则以双引号来定义
  + `last -n 5 | awk '{print $1 "¥t lines: " NR "¥t columes: " NF}'`



+ awk的逻辑运算符
  + `>`:大于
  + `<`:小于
  + `>=`:大于等于
  + `<=`:小于等于
  + `==`:等于
  + `!=`:不等于
  + 赋值则用=
+ 查阅第三列小于10以下的数据，并且仅列出账号与第三列
  + `cat /etc/passwd | awk '{FS=":"} $3 < 10 {print $1 "¥t " $3}'`  读入第一行时，变量$1$2默认还是以空格键为分隔的
  + `cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "¥t " $3}'`



+ `awk 'NR=1{printf "%10s %10s %10s %10s %10s¥n",$1,$2,$3,$4,"Total" };NR=2{total = $2 + $3 + $4;printf "%10s %10d %10d %10d %10.2f¥n", $1, $2, $3, $4, total}'`



3.文件比较工具

+ 通常是同一个软件的不同版本之间，比较配置文件与源文件的区别。

+ diff [-bBi] from-file to-file
  + 用在比较两个文件之间的区别的，并且是以行为单位来比较的。一般用在ASCII纯文本文件的比较上。
  + diff通常是用在同一的文件（或软件）的新旧版本区别上！
  + from-file：一个文件名，作为欲比较的文件名；
  + to-file：一个文件名，作为目的比较文件的文件名。
  + 注意：from-file或to-file可以 - 替换，那个 - 代表“Standard input”之意思。
  + -b：忽略一行当中仅有多个空白的区别
  + -B：忽略空白行的区别。
  + -i：忽略大小写的区别。



+ cmp [-s] file1 file2
  + 比较非纯文本文件，主要利用“字节”单位去比较
  + -s：将所有的不同点的字节出都列出来。因为cmp默认仅会输出第一个发现的不同点。



+ patch
  + 升级：将旧的文件升级成新的文件。先比较新旧版本的区别，并将区别文件制作成为补丁文件，再由补丁文件更新旧文件即可。
  + 制作补丁文件
    + `diff -Naur passwd.old passwd.new > passwd.patch`
  + patch -pN < patch_file <==更新
  + patch -R -pN < patch_file <==还原
  + -p：后面的N表示取消几层目录的意思。
  + -R：代表还原，将新的文件还原成原来旧的版本。



4.文件打印准备：pr

+ pr /etc/man.config